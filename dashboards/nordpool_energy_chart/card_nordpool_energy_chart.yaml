# This code should be copy-pasted into a lovelace card.
# Requires the custom:config-template-card, custom:apexcharts-card, custom:nordpool-card and custom:congif-template-card to be installed. 

type: 'custom:config-template-card'
variables:
  currency: '''öre'''
  chart_cutoff: -5
  grid_import_sensor: '''sensor.sigen_accumulated_grid_energy_import'''
  chart_title: '''Electricity prices today'''  
  total_purchease_price_text: '''Total purchease price'''
  grid_import_text: '''Grid Import'''
  lowest_price_text: '''Lowest to come'''
  highest_price_text: '''Highest to come'''
  price_now_text: '''Price now'''
  now_text: '''Now'''
  nordpool_sensor: '''sensor.nordpool'''
  decimals_in_prices: 0
  decimals_in_energy: 3
  total_max_nordpool_price: '`${ states[''sensor.nordpool''].attributes.raw_today.concat(states[''sensor.nordpool''].attributes.raw_tomorrow).map(data => data.value).reduce((a, b) => Math.max(a, b), -Infinity) }`'
  total_min_nordpool_price: '`${ states[''sensor.nordpool''].attributes.raw_today.concat(states[''sensor.nordpool''].attributes.raw_tomorrow).map(data => data.value).reduce((a, b) => Math.min(a, b), Infinity) }`'
  total_nordpool_prices: '`${ states[''sensor.nordpool''].attributes.raw_today.concat(states[''sensor.nordpool''].attributes.raw_tomorrow).map(data => data.value).reduce((a, b) => a + b, 0) }`'

  setchart_cutoff: |
    min_max_price => {
      if (min_max_price[0] <= 0) {
          return "auto";
      }
      return min_max_price[1] - min_max_price[0] + (min_max_price[0] * 0,75)
    }

entities:
  - input_number.total_nordpool_hours_available
card:
  type: custom:apexcharts-card
  graph_span: "${ states['sensor.nordpool'].attributes.raw_today.length + states['sensor.nordpool'].attributes.raw_tomorrow.length + 'h' }"
  yaxis:
    - id: y1
      min: ${setchart_cutoff([total_min_nordpool_price,total_max_nordpool_price])}
      max: auto
      apex_config:
        opposite: false
        forceNiceScale: true
        decimalsInFloat: ${decimals_in_prices}
        labels:
          formatter: |
            EVAL:function(value) {
              return value.toFixed(0) + " öre";
            }
    - id: y2
      min: 0
      max: auto
      apex_config:
        opposite: true
        forceNiceScale: true
        decimalsInFloat: ${decimals_in_energy}
        labels:
          formatter: |
            EVAL:function(value) {
              return value.toFixed(1) +" kWh";
            }
  apex_config:
    chart:
      height: 340px
    legend:
      show: false
    title:
      floating: false
      align: center
      style:
        fontSize: 20px
        fontWeight: bold
    xaxis:
      labels:
        datetimeFormatter:
          hour: HH:mm
  show:
    last_updated: true
  experimental:
    color_threshold: true
  header:
    title: ${chart_title}
    show: true
    show_states: true
    colorize_states: true
  span:
    start: day
  now:
    show: true
    label: ${now_text}
  series:
    - entity: ${nordpool_sensor}
      yaxis_id: y1
      name: ${total_purchease_price_text}
      offset: '-30min'
      float_precision: ${decimals_in_prices}
      show:
        extremas: true
        in_header: false
        header_color_threshold: true
      type: column
      data_generator: >
        return (entity.attributes.raw_today.map((start, index) => {
          return [new Date(start["start"]).getTime(), entity.attributes.raw_today[index]["value"]];
        })).concat(entity.attributes.raw_tomorrow.map((start, index) => {

        return [new Date(start["start"]).getTime(),
        entity.attributes.raw_tomorrow[index]["value"]];

        }));
      color_threshold:
        - value: -1000
          color: '#30c752'
          opacity: 1
        - value: >-
            `${
            parseFloat(states['input_number.low_threshold_nordpool_price_bottom'].state)
            }`
        - value: >-
            `${
            parseFloat(states['input_number.low_threshold_nordpool_price'].state)
            }`
          color: '#ffed4a'
          opacity: 1
        - value: >-
            `${
            parseFloat(states['input_number.high_threshold_nordpool_price'].state)
            }`
          color: '#fd7e14'
        - value: >-
            `${
            parseFloat(states['input_number.high_threshold_nordpool_price_top'].state)
            }`
          color: '#dc3545'
    - entity: ${grid_import_sensor}
      yaxis_id: y2
      name: ${grid_import_text}
      color: '#007bff'
      float_precision: ${decimals_in_energy}
      show:
        extremas: false
        in_header: false
        header_color_threshold: true
      type: line
      stroke_width: 3
      extend_to: false
      group_by:
        func: delta
        duration: 1h
    - entity: ${nordpool_sensor}
      type: column
      color: '#28a745'
      float_precision: ${decimals_in_prices}
      stroke_width: 2
      name: ${lowest_price_text}
      show:
        in_chart: false
        legend_value: false
      group_by:
        func: min
        duration: 1d
      data_generator: >
        const now = new Date().getTime(); const futureData =
        entity.attributes.raw_today.concat(entity.attributes.raw_tomorrow).filter(data
        => new Date(data.start).getTime() >= now); return futureData.map((data,
        index) => {
          return [new Date(data.start).getTime(), futureData[index].value];
        });
    - entity: ${nordpool_sensor}
      name: ${price_now_text}
      color: orange
      type: column
      show:
        in_chart: false
      float_precision: ${decimals_in_prices}
    - entity: ${nordpool_sensor}
      type: column
      color: '#dc3545'
      float_precision: ${decimals_in_prices}
      stroke_width: 2
      name: "${ states[nordpool_sensor].attributes.raw_today.concat(states[nordpool_sensor].attributes.raw_tomorrow).map(data => data.value).reduce((a, b) => Math.max(a, b), -Infinity) +' '}"
      show:
        in_chart: false
        legend_value: false
      group_by:
        func: max
        duration: 1d
      data_generator: >
        const now = new Date().getTime(); const futureData =
        entity.attributes.raw_today.concat(entity.attributes.raw_tomorrow).filter(data
        => new Date(data.start).getTime() >= now); return futureData.map((data,
        index) => {
          return [new Date(data.start).getTime(), futureData[index].value];
        });
layout_options:
  grid_columns: full
